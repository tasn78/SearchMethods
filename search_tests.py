import unittest
from search_algorithms import SearchAlgorithms
from graph import Graph


# Generated by ChatGPT asking "Let's create unit tests to check for all of the algorithms."
# and providing current algorithm code.
class TestSearchAlgorithms(unittest.TestCase):

    def setUp(self):
        # Set up a simple graph with 5 nodes
        self.graph = Graph()
        self.graph.add_edge("A", "B")
        self.graph.add_edge("B", "C")
        self.graph.add_edge("C", "D")
        self.graph.add_edge("D", "E")

        # Add the disconnected node "F"
        self.graph.set_city_coords({
            "A": (0, 0),
            "B": (1, 0),
            "C": (2, 0),
            "D": (3, 0),
            "E": (4, 0),
            "F": (5, 5)  # Add coordinates for "F" to avoid KeyError -
                         # Updated by ChatGPT with screenshots of test_no_path errors
        })

    # Test BFS algorithm
    def test_bfs(self):
        path = SearchAlgorithms.bfs(self.graph, "A", "E")
        self.assertEqual(path, ["A", "B", "C", "D", "E"])

    # Test DFS algorithm
    def test_dfs(self):
        path = SearchAlgorithms.dfs(self.graph, "A", "E")
        self.assertEqual(path, ["A", "B", "C", "D", "E"])

    # Test ID-DFS algorithm
    def test_iddfs(self):
        path = SearchAlgorithms.iddfs(self.graph, "A", "E")
        self.assertEqual(path, ["A", "B", "C", "D", "E"])

    # Test Best-First Search algorithm
    def test_best_first_search(self):
        euclidean_distance = self.create_euclidean_distance(self.graph.city_coords)
        path = SearchAlgorithms.best_first_search(self.graph, "A", "E", euclidean_distance)
        self.assertEqual(path, ["A", "B", "C", "D", "E"])

    # Test A* Search algorithm
    def test_a_star(self):
        euclidean_distance = self.create_euclidean_distance(self.graph.city_coords)
        path = SearchAlgorithms.a_star(self.graph, "A", "E", euclidean_distance)
        self.assertEqual(path, ["A", "B", "C", "D", "E"])

    # Helper function for Euclidean distance
    def create_euclidean_distance(self, city_coords):
        def euclidean_distance(city1, city2):
            x1, y1 = city_coords[city1]
            x2, y2 = city_coords[city2]
            return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5
        return euclidean_distance

    # Test no path available, updated by ChatGPT with screenshots of errors - no heuristic argument for A*
    def test_no_path(self):
        algorithms = {
            "BFS": SearchAlgorithms.bfs,
            "DFS": SearchAlgorithms.dfs,
            "ID-DFS": lambda graph, start, goal: SearchAlgorithms.iddfs(graph, start, goal, max_depth=100),
            "Best-First Search": lambda graph, start, goal: SearchAlgorithms.best_first_search(graph, start, goal,
                                                                                               self.create_euclidean_distance(
                                                                                                   self.graph.city_coords)),
            "A* Search": lambda graph, start, goal: SearchAlgorithms.a_star(graph, start, goal,
                                                                            self.create_euclidean_distance(
                                                                                self.graph.city_coords))
        }

        # Ensure F is disconnected from the rest of the graph
        for algo_name, algo_function in algorithms.items():
            with self.subTest(algorithm=algo_name):
                path = algo_function(self.graph, "A", "F")
                self.assertIsNone(path)  # Expect None for disconnected nodes

    # Test same start and end state
    def test_same_start_goal(self):
        algorithms = {
            "BFS": SearchAlgorithms.bfs,
            "DFS": SearchAlgorithms.dfs,
            "ID-DFS": lambda graph, start, goal: SearchAlgorithms.iddfs(graph, start, goal, max_depth=100),
            "Best-First Search": lambda graph, start, goal: SearchAlgorithms.best_first_search(graph, start, goal,
                                                                                               self.create_euclidean_distance(
                                                                                                   self.graph.city_coords)),
            "A* Search": lambda graph, start, goal: SearchAlgorithms.a_star(graph, start, goal,
                                                                            self.create_euclidean_distance(
                                                                                self.graph.city_coords))
        }

        for algo_name, algo_function in algorithms.items():
            with self.subTest(algorithm=algo_name):
                path = algo_function(self.graph, "A", "A")
                self.assertEqual(path, ["A"])

    # Provided code above to ChatGPT, asked "Is this sufficient to confirm if the algorithms are working correctly?"
    # ChatGPT recommended adding the following:
    def test_circular_graph(self):
        self.graph.add_edge("E", "D")  # Add the circular link at "E -> D" only, no direct A->E link
        algorithms = {
            "BFS": SearchAlgorithms.bfs,
            "DFS": SearchAlgorithms.dfs,
            "ID-DFS": lambda graph, start, goal: SearchAlgorithms.iddfs(graph, start, goal, max_depth=100),
            "Best-First Search": lambda graph, start, goal: SearchAlgorithms.best_first_search(graph, start, goal,
                                                                                        self.create_euclidean_distance(
                                                                                            self.graph.city_coords)),
            "A* Search": lambda graph, start, goal: SearchAlgorithms.a_star(graph, start, goal,
                                                                            self.create_euclidean_distance(
                                                                                self.graph.city_coords))
        }

        for algo_name, algo_function in algorithms.items():
            with self.subTest(algorithm=algo_name):
                path = algo_function(self.graph, "A", "E")
                self.assertEqual(path, ["A", "B", "C", "D", "E"])

    def test_multiple_paths(self):
        self.graph.add_edge("B", "E")  # Add an alternate path directly from B to E
        algorithms = {
            "BFS": SearchAlgorithms.bfs,
            "DFS": SearchAlgorithms.dfs,
            "ID-DFS": lambda graph, start, goal: SearchAlgorithms.iddfs(graph, start, goal, max_depth=100),
            "Best-First Search": lambda graph, start, goal: SearchAlgorithms.best_first_search(graph, start, goal,
                                                                                        self.create_euclidean_distance(
                                                                                            self.graph.city_coords)),
            "A* Search": lambda graph, start, goal: SearchAlgorithms.a_star(graph, start, goal,
                                                                            self.create_euclidean_distance(
                                                                                self.graph.city_coords))
        }

        for algo_name, algo_function in algorithms.items():
            with self.subTest(algorithm=algo_name):
                path = algo_function(self.graph, "A", "E")
                self.assertIn(path, [["A", "B", "E"], ["A", "B", "C", "D", "E"]])  # Either path is valid


if __name__ == "__main__":
    unittest.main()