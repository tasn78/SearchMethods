# Search algorithms the user can choose from
import heapq
import networkx as nx


class SearchAlgorithms:
    # Breadth first search
    # Explores all nodes at current depth before moving deeper
    @staticmethod
    def bfs(graph, start, goal):
        visited = set()  # Keeps track of visited nodes
        queue = [[start]]  # Queue of paths to explore

        # If the start and goal are the same, return the path immediately
        if start == goal:  # Updated after unit test test_no_path
            return [start]

        while queue:
            path = queue.pop(0)  # Dequeue the first path
            node = path[-1]  # Get the last node in the path

            if node == goal:  # If the goal is reached, return the path
                return path

            if node not in visited:
                visited.add(node) # Keeps track of visited nodes
                # Check if the graph is an instance of your custom Graph class or a networkx.Graph
                # Updated using ChatGPT when implementing networkx_comparison.py
                if isinstance(graph, nx.Graph):
                    neighbors = graph.neighbors(node)  # Use networkx neighbors method
                else:
                    neighbors = graph.get_neighbors(node)  # Use custom Graph get_neighbors method

                # For each neighbor not visited, create a new path that includes this neighbor and adds to queue
                for neighbor in neighbors:
                    if neighbor not in visited:
                        new_path = list(path)
                        new_path.append(neighbor)
                        queue.append(new_path)

        return None  # Return None if no path is found after the queue is exhausted

    # Depth first search
    # Explores as deeply as possible alone each branch before backtracking
    @staticmethod
    def dfs(graph, start, goal):
        visited = set()  # Keeps track of visited nodes
        stack = [[start]]  # A list (stack) where each element is a path to explore

        while stack:
            path = stack.pop()  # Pops the last path from the stack
            node = path[-1]

            if node == goal:
                return path

            if node not in visited:
                visited.add(node)  # Marks node as visited
                # Added from ChatGPT during implementation of networkx_comparison.py
                # Check if the graph is an instance of networkx or custom Graph class
                if isinstance(graph, nx.Graph):
                    neighbors = graph.neighbors(node)  # Use networkx method
                else:
                    neighbors = graph.get_neighbors(node)  # Use custom Graph method

                # Gets all neighbors of this node, for each neighbor - push it onto the stack
                for neighbor in neighbors:
                    new_path = list(path)
                    new_path.append(neighbor)
                    stack.append(new_path)
        return None

    # ID-DFS search
    # Combines DFS and BFS by performing DFS searches with increasing depths
    @staticmethod
    def iddfs(graph, start, goal, max_depth=100):
        def dls(node, goal, depth, visited):
            # Base case
            # Returns path with just this node
            if node == goal:
                return [node]
            if depth == 0:
                return None
            visited.add(node)

            # For each neighbor of the current node, perform dls recursively (subtracting depth - 1)
            for neighbor in graph.get_neighbors(node):
                if neighbor not in visited:
                    result = dls(neighbor, goal, depth - 1, visited)
                    if result:
                        return [node] + result
            return None

        # Iterates from depth 0 to max_depth (100)
        for depth in range(max_depth):
            visited = set()  # Reset visited nodes for each depth
            # If dls (Depth Limited Search) finds the goal, returns the result
            result = dls(start, goal, depth, visited)
            if result:
                return result

        return None  # Return None if no path is found

    # Best first search
    # Heuristic uses Euclidean distance to prioritize nodes that are closer to the goal
    # Generated by ChatGPT - provided previous code, asked "How would I implement best first search and A*
    # implementation?"
    @staticmethod
    def best_first_search(graph, start, goal, heuristic):
        visited = set()  # Keeps track of visited nodes
        priority_queue = [(heuristic(start, goal), [start])] # Paths are ordered by smallest heuristic value
        while priority_queue:
            _, path = heapq.heappop(priority_queue)  # Dequeues the path with the smallest heuristic value
            node = path[-1] # Gets the last node of this path

            if node == goal:
                return path

            if node not in visited:
                visited.add(node) # Marks visited
                for neighbor in graph.get_neighbors(node):  # For each neighbor, create a new path
                    new_path = list(path)
                    new_path.append(neighbor)
                    # Calculates the heuristic score for the new path and pushes it to priority queue
                    heapq.heappush(priority_queue, (heuristic(neighbor, goal), new_path))
        return None

    # A* search
    # Combines BFS and Best-First search by considering actual cost and estimated cost to goal
    # Heuristic uses Euclidean distance
    # Generated by ChatGPT - provided previous code, asked "How would I implement a best first search and A*
    # implementation?"
    @staticmethod
    def a_star(graph, start, goal, heuristic):
        visited = set()
        g_score = {start: 0} # Dictionary with cost to reach each node
        # Dictionary with the estimated cost of the cheapest solution (actual + heuristic to reach goal from each node)
        f_score = {start: heuristic(start, goal)}
        priority_queue = [(f_score[start], [start])]

        while priority_queue:
            _, path = heapq.heappop(priority_queue)  # Extract the path, ignore the priority
            node = path[-1]  # The last node in the path

            if node == goal:
                return path

            if node not in visited:
                visited.add(node)  # Mark as visited
                # Used ChatGPT - added when implementing networkx.comparison
                # Check if the graph is an instance of networkx.Graph or your custom Graph class
                if isinstance(graph, nx.Graph):
                    neighbors = graph.neighbors(node)  # Use networkx method
                else:
                    neighbors = graph.get_neighbors(node)  # Use custom Graph method

                for neighbor in neighbors:
                    tentative_g_score = g_score[node] + 1  # Assuming equal edge cost
                    if tentative_g_score < g_score.get(neighbor, float('inf')):
                        # If tentative is lower than current g score, update g and f score
                        g_score[neighbor] = tentative_g_score
                        f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)
                        # Updates the paths and pushes it onto priority queue
                        new_path = list(path)
                        new_path.append(neighbor)
                        heapq.heappush(priority_queue, (f_score[neighbor], new_path))

        return None # No path found
